<!doctype html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Admin • Chats (somente leitura)</title>
    <style>
        :root {
            --bg: #f0f2f5;
            --panel: #fff;
            --border: #e5e7eb;
            --text: #111827;
            --muted: #6b7280;
            --accent: #00a884;
            --hover: #f3f4f6;
            --active: #e7f7f3;
            --in: #fff;
            --out: #d9fdd3;
            --shadow: 0 1px 2px rgba(16, 24, 40, .08);
            --radius: 12px;
            --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            font-family: var(--font);
            color: var(--text);
            background: var(--bg);
            overflow: hidden
        }

        .app {
            height: 100vh;
            display: flex
        }

        .side {
            width: 360px;
            min-width: 320px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column
        }

        .sideTop {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 14px;
            border-bottom: 1px solid var(--border)
        }

        .brand {
            display: flex;
            gap: 10px;
            align-items: center
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #9ca3af
        }

        .dot.ok {
            background: var(--accent)
        }

        .title {
            font-weight: 700
        }

        .pill {
            font-size: 12px;
            color: var(--muted)
        }

        .search {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border)
        }

        .search input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 999px;
            background: #fafafa;
            outline: none
        }

        .list {
            overflow: auto
        }

        .item {
            display: flex;
            gap: 10px;
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f2f2f2
        }

        .item:hover {
            background: var(--hover)
        }

        .item.active {
            background: var(--active)
        }

        .avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(135deg, #e5e7eb, #cbd5e1)
        }

        .meta {
            flex: 1;
            min-width: 0
        }

        .row1 {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px
        }

        .name {
            font-weight: 650;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis
        }

        .time {
            font-size: 12px;
            color: var(--muted)
        }

        .row2 {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .prev {
            font-size: 13px;
            color: var(--muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis
        }

        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0
        }

        .head {
            height: 60px;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px
        }

        .hLeft {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 0
        }

        .hName {
            font-weight: 750;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis
        }

        .hSub {
            font-size: 12px;
            color: var(--muted);
            margin-top: 2px
        }

        /* ✅ viewport do chat */
        .chatBody {
            flex: 1;
            overflow: auto;
            padding: 18px;
            background: var(--bg);
            position: relative;
        }

        /* ✅ empty-state fica separado e NÃO é removido */
        .empty {
            max-width: 560px;
            margin: 70px auto 0;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 18px;
            box-shadow: var(--shadow);
            text-align: center;
            color: var(--muted)
        }

        .msgRow {
            display: flex;
            margin: 8px 0
        }

        .msgRow.in {
            justify-content: flex-start
        }

        .msgRow.out {
            justify-content: flex-end
        }

        .bubble {
            max-width: min(720px, 84%);
            padding: 10px 10px 8px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            white-space: pre-wrap;
            word-break: break-word
        }

        .in .bubble {
            background: var(--in);
            border-top-left-radius: 6px
        }

        .out .bubble {
            background: var(--out);
            border-top-right-radius: 6px
        }

        .mFoot {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            align-items: center;
            margin-top: 6px;
            font-size: 11px;
            color: var(--muted)
        }

        .divider {
            display: flex;
            justify-content: center;
            margin: 14px 0
        }

        .divider span {
            font-size: 12px;
            color: var(--muted);
            background: #e9eef2;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 6px 10px
        }

        .foot {
            height: 64px;
            background: var(--panel);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0 14px
        }

        .foot input {
            flex: 1;
            padding: 12px 14px;
            border: 1px solid var(--border);
            border-radius: 999px;
            background: #fafafa
        }

        .foot button {
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #f9fafb;
            color: var(--muted)
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
            font-size: 12px;
            color: #0f172a;
            background: #eef2f7;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 2px 6px
        }

        @media (max-width:880px) {
            .side {
                width: 320px
            }

            .bubble {
                max-width: 92%
            }
        }
    </style>
</head>

<body>
    <div class="app">
        <aside class="side">
            <div class="sideTop">
                <div class="brand">
                    <div id="connDot" class="dot"></div>
                    <div>
                        <div class="title">Chats</div>
                        <div class="pill">somente leitura</div>
                    </div>
                </div>
                <div class="pill"><span class="kbd">/admin/chats</span></div>
            </div>

            <div class="search">
                <input id="q" type="search" placeholder="Buscar por nome ou número…" autocomplete="off" />
            </div>

            <div id="list" class="list"></div>
        </aside>

        <main class="main">
            <div class="head">
                <div class="hLeft">
                    <div class="avatar" style="width:40px;height:40px;"></div>
                    <div style="min-width:0">
                        <div id="hName" class="hName">Selecione um chat</div>
                        <div id="hSub" class="hSub"></div>
                    </div>
                </div>
                <div class="pill" id="statusTxt">Conectando…</div>
            </div>

            <!-- ✅ chat viewport -->
            <div id="chatBody" class="chatBody">
                <div id="empty" class="empty">
                    Abra um chat na lista à esquerda.<br />
                    O painel atualiza em tempo real via <span class="kbd">/api/stream</span>.
                </div>
                <!-- ✅ mensagens vão aqui -->
                <div id="msgs"></div>
            </div>

            <div class="foot">
                <input disabled placeholder="Visualização apenas (não envia mensagens)" />
                <button disabled>Enviar</button>
            </div>
        </main>
    </div>

    <script>
        const $ = (id) => document.getElementById(id);

        const el = {
            connDot: $('connDot'),
            statusTxt: $('statusTxt'),
            q: $('q'),
            list: $('list'),
            hName: $('hName'),
            hSub: $('hSub'),
            chatBody: $('chatBody'),
            empty: $('empty'),
            msgs: $('msgs'),
        };

        const state = {
            chats: new Map(),          // wa_id -> {wa_id,title,last_ts,last_text}
            selected: null,
            filter: '',
            nearBottom: true,

            // Solução A (buffer no front)
            msgBuffer: new Map(),      // wa_id -> [msg]
            msgSeen: new Map(),        // wa_id -> Set(key)
        };

        window.__CHATS_STATE = state;

        const MAX_BUFFER_PER_CHAT = 800;

        function fmtTime(ts) {
            const d = new Date(ts || Date.now());
            return new Intl.DateTimeFormat('pt-BR', { hour: '2-digit', minute: '2-digit' }).format(d);
        }
        function fmtDay(ts) {
            const d = new Date(ts || Date.now());
            return new Intl.DateTimeFormat('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' }).format(d);
        }
        function dividerLabel(ts) {
            const d = new Date(ts || Date.now());
            const now = new Date();
            const a = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
            const b = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            const diff = Math.round((a - b) / (24 * 3600 * 1000));
            if (diff === 0) return 'hoje';
            if (diff === -1) return 'ontem';
            return fmtDay(ts);
        }

        function setConn(ok) {
            el.connDot.classList.toggle('ok', !!ok);
            el.statusTxt.textContent = ok ? 'Online' : 'Reconectando…';
        }

        function setEmptyVisible(v) {
            el.empty.style.display = v ? 'block' : 'none';
        }

        function clearMessages() {
            el.msgs.innerHTML = '';
        }

        function onBodyScroll() {
            state.nearBottom = (el.chatBody.scrollTop + el.chatBody.clientHeight) >= (el.chatBody.scrollHeight - 120);
        }
        el.chatBody.addEventListener('scroll', onBodyScroll, { passive: true });

        function scrollToBottom(force = false) {
            if (force || state.nearBottom) el.chatBody.scrollTop = el.chatBody.scrollHeight;
        }

        // ---------- BUFFER ----------
        function getSeenSet(wa_id) {
            let s = state.msgSeen.get(wa_id);
            if (!s) { s = new Set(); state.msgSeen.set(wa_id, s); }
            return s;
        }

        function getBufferArr(wa_id) {
            let a = state.msgBuffer.get(wa_id);
            if (!a) { a = []; state.msgBuffer.set(wa_id, a); }
            return a;
        }

        function msgKeyFromEvent(evt) {
            const wamid = String(evt?.wamid || '').trim();
            if (wamid) return `wamid:${wamid}`;

            // fallback "estável" em segundos (evita duplicatas por ms)
            const when = Number(evt?.ts) || 0;
            const role = (evt?.dir === 'out') ? 'assistant' : 'user';
            const text = String(evt?.text || '').trim();
            if (when && text) return `h:${Math.floor(when / 1000)}|${role}|${text}`;

            // só usa id se não der pra construir fallback
            const id = String(evt?.id || '').trim();
            if (id) return `id:${id}`;

            return `x:${Date.now()}|${Math.random()}`;
        }

        function normalizeEventToMsg(evt) {
            const when = Number(evt?.ts) || Date.now();
            const isOut = evt?.dir === 'out';
            const kind = String(evt?.kind || 'text');

            let text = String(evt?.text || '').trim();
            if (!text) {
                if (kind === 'audio') text = '[áudio]';
                else if (kind === 'image') text = '[imagem]';
                else if (kind === 'video') text = '[vídeo]';
                else if (kind === 'document') text = '[documento]';
                else if (kind && kind !== 'text') text = `[${kind}]`;
            }

            return {
                _k: msgKeyFromEvent(evt),
                role: isOut ? 'assistant' : 'user',
                text,
                ts_ms: when,
                kind,
            };
        }

        function bufferPush(wa_id, msg) {
            if (!wa_id || !msg) return false;

            const seen = getSeenSet(wa_id);
            if (seen.has(msg._k)) return false;
            seen.add(msg._k);

            const arr = getBufferArr(wa_id);
            arr.push(msg);

            if (arr.length > MAX_BUFFER_PER_CHAT) {
                arr.splice(0, arr.length - MAX_BUFFER_PER_CHAT);
            }

            return true;
        }

        function normalizeHistoryToMsg(m) {
            const when = Number(m?.ts_ms) || (m?.ts ? Date.parse(m.ts) : Date.now());
            const role = String(m?.role || 'user');
            const text = (m?.audio_text && (m?.text || '').startsWith('[audio]'))
                ? String(m.audio_text || '')
                : String(m?.text || m?.audio_text || '');

            const wamid = String(m?.wamid || '').trim();
            const key = wamid
                ? `wamid:${wamid}`
                : `h:${Math.floor(when / 1000)}|${role}|${text}`;
            return { _k: key, role, text, ts_ms: when, kind: String(m?.kind || 'text') };
        }

        function mergeAndDedupeMessages(histMsgs, liveMsgs) {
            const map = new Map();
            for (const x of (histMsgs || [])) map.set(x._k, x);
            for (const x of (liveMsgs || [])) map.set(x._k, x);
            const merged = Array.from(map.values());
            merged.sort((a, b) => (a.ts_ms || 0) - (b.ts_ms || 0));
            return merged;
        }

        // ---------- RENDER ----------
        function renderList() {
            el.list.innerHTML = '';

            const arr = Array.from(state.chats.values())
                .sort((a, b) => (b.last_ts || 0) - (a.last_ts || 0))
                .filter(c => {
                    if (!state.filter) return true;
                    const f = state.filter.toLowerCase();
                    return (String(c.title || '').toLowerCase().includes(f) || String(c.wa_id || '').includes(f));
                });

            if (arr.length === 0) {
                const div = document.createElement('div');
                div.className = 'empty';
                div.style.margin = '16px';
                div.textContent = 'Nenhum chat ainda.';
                el.list.appendChild(div);
                return;
            }

            for (const c of arr) {
                const it = document.createElement('div');
                it.className = 'item' + (state.selected === c.wa_id ? ' active' : '');
                it.onclick = () => openChat(c.wa_id);

                const av = document.createElement('div');
                av.className = 'avatar';

                const meta = document.createElement('div');
                meta.className = 'meta';

                const row1 = document.createElement('div');
                row1.className = 'row1';

                const name = document.createElement('div');
                name.className = 'name';
                name.textContent = c.title || c.wa_id;

                const time = document.createElement('div');
                time.className = 'time';
                time.textContent = c.last_ts ? fmtTime(c.last_ts) : '';

                row1.appendChild(name); row1.appendChild(time);

                const row2 = document.createElement('div');
                row2.className = 'row2';

                const prev = document.createElement('div');
                prev.className = 'prev';
                prev.textContent = c.last_text || '';

                row2.appendChild(prev);

                meta.appendChild(row1);
                meta.appendChild(row2);

                it.appendChild(av);
                it.appendChild(meta);

                el.list.appendChild(it);
            }
        }

        function appendDivider(ts) {
            const d = document.createElement('div');
            d.className = 'divider';
            d.dataset.day = new Date(ts || Date.now()).toDateString();
            const s = document.createElement('span');
            s.textContent = dividerLabel(ts);
            d.appendChild(s);
            el.msgs.appendChild(d);
        }

        function appendMsg(msg) {
            const isOut = msg.role === 'assistant';
            const row = document.createElement('div');
            row.className = 'msgRow ' + (isOut ? 'out' : 'in');

            const bub = document.createElement('div');
            bub.className = 'bubble';
            bub.textContent = msg.text || '';

            const foot = document.createElement('div');
            foot.className = 'mFoot';

            const t = document.createElement('span');
            t.textContent = fmtTime(msg.ts_ms || Date.now());

            foot.appendChild(t);
            bub.appendChild(foot);
            row.appendChild(bub);

            el.msgs.appendChild(row);
        }

        function ensureDividerIfNeeded(ts_ms) {
            const day = new Date(ts_ms || Date.now()).toDateString();
            // acha último divider
            for (let i = el.msgs.children.length - 1; i >= 0; i--) {
                const node = el.msgs.children[i];
                if (node.classList && node.classList.contains('divider')) {
                    if (node.dataset.day !== day) appendDivider(ts_ms);
                    return;
                }
                if (node.classList && node.classList.contains('msgRow')) {
                    // se não tem divider no final, cria (caso raro)
                    break;
                }
            }
            appendDivider(ts_ms);
        }

        function renderMessages(messages) {
            clearMessages();

            if (!messages || messages.length === 0) {
                setEmptyVisible(true);
                return;
            }

            setEmptyVisible(false);

            let lastDay = null;
            for (const m of messages) {
                const when = Number(m.ts_ms) || Date.now();
                const day = new Date(when).toDateString();
                if (day !== lastDay) {
                    appendDivider(when);
                    lastDay = day;
                }
                appendMsg({ role: m.role, text: m.text, ts_ms: when });
            }
            scrollToBottom(true);
        }

        // ---------- DATA ----------
        function upsertChatFromEvt(evt) {
            const wa_id = String(evt?.wa_id || '').trim();
            if (!wa_id) return;

            const prev = state.chats.get(wa_id) || { wa_id };
            const next = { ...prev };

            if (String(evt.type) === 'message') {
                next.last_ts = Number(evt.ts) || Date.now();
                const txt = String(evt.text || '').trim() || (evt.kind ? `[${evt.kind}]` : '');
                next.last_text = txt;
                if (!next.title) next.title = wa_id;
            } else {
                next.last_ts = Math.max(Number(prev.last_ts) || 0, Number(evt.ts) || 0);
            }

            state.chats.set(wa_id, next);
        }

        async function openChat(wa_id) {
            const id = String(wa_id || '').trim();
            if (!id) return;

            state.selected = id;
            renderList();

            el.hName.textContent = id;
            el.hSub.textContent = 'Carregando…';

            // mostra imediatamente o que já chegou via SSE
            const liveNow = state.msgBuffer.get(id) || [];
            if (liveNow.length) {
                renderMessages(liveNow);
            } else {
                renderMessages([]);
            }

            let j;
            try {
                const r = await fetch('/admin/api/chats/' + encodeURIComponent(id) + '/messages');
                j = await r.json();
            } catch {
                j = { ok: false, messages: [], title: id };
            }

            el.hName.textContent = j.title || id;
            el.hSub.textContent = id;

            const histMsgs = (Array.isArray(j.messages) ? j.messages : []).map(normalizeHistoryToMsg);
            const liveMsgs = state.msgBuffer.get(id) || [];
            const merged = mergeAndDedupeMessages(histMsgs, liveMsgs);

            renderMessages(merged);

            console.debug('[openChat]', id, { hist: histMsgs.length, live: liveMsgs.length, merged: merged.length });
        }

        async function loadChats() {
            const r = await fetch('/admin/api/chats?limit=2000');
            const j = await r.json();
            (j.chats || []).forEach(c => state.chats.set(c.wa_id, c));
            renderList();
        }

        // ---------- SSE ----------
        function connectSSE() {
            const es = new EventSource('/api/stream');

            const handle = (eventName) => (e) => {
                let evt;
                try { evt = JSON.parse(e.data); } catch { return; }

                const wa_id = String(evt?.wa_id || '').trim();
                if (!wa_id) return;

                evt.type = String(evt.type || eventName);

                upsertChatFromEvt(evt);

                if (evt.type === 'message') {
                    const msg = normalizeEventToMsg(evt);
                    const added = bufferPush(wa_id, msg);

                    if (added && state.selected === wa_id) {
                        appendMsg({ role: msg.role, text: msg.text, ts_ms: msg.ts_ms });
                        scrollToBottom();
                    }
                }

                renderList();
            };

            es.addEventListener('ready', () => setConn(true));
            es.addEventListener('ping', () => { });

            es.addEventListener('message', handle('message'));
            es.addEventListener('state', handle('state'));
            es.addEventListener('ack', handle('ack'));

            es.onerror = () => setConn(false);
        }

        // ---------- BOOT ----------
        el.q.addEventListener('input', (e) => {
            state.filter = String(e.target.value || '').trim();
            renderList();
        });

        (async function boot() {
            setConn(false);
            await loadChats();
            connectSSE();
        })();
    </script>
</body>

</html>